\documentclass[a4paper, 11pt, twoside, notitlepage, openany, onecolumn, final]{report}

\usepackage{style}

\title{\tb{Álgebra Computacional}}
\author{
	Álvaro García Tenorio
	\and
	Miguel Pascual Domínguez
}
\date{\today}

\begin{document}
	\maketitle
	\begin{abstract}
		En este documento se recopilan unas breves explicaciones sobre el funcionamiento de los algoritmos implementados.
	\end{abstract}
	\tableofcontents
	\chapter{Algoritmos implementados}
	\section{Algoritmos auxiliares}
	\subsection{Algoritmo de exponenciación binaria}
	Sea $A$ un anillo conmutativo unitario. Consideremos $a\in A$ y $n\in \N$ de manera que $n>0$. Nuestro objetivo es tener un algoritmo eficiente para calcular $a^n$.
	
	Para ello, tomemos la representación binaria de $n$, es decir, $n= 2^k+\sum_{i=0}^{k-1}n_i2^i$, así como la sucesión $\{r_i\}_{i=0}^{k}$ definida de la siguiente manera.
	\begin{equation*}
		r_i:=\left\{\begin{array}{lcr}
			a &\text{ si }& i=k\\
			r_{i+1}^2a &\text{si}& n_i=1\\
			r_{i+1}^2 &\text{si}& n_i=0
		\end{array}\right.
	\end{equation*}
	Demostremos que $r_0$ es $a^n$. Para ello, veamos por inducción que, $r_i= a^{\lfloor n/2^i\rfloor}$. La demostración es inmediata, una vez se comprueba que
	\begin{equation*}
		\lfloor n/2^i\rfloor = \sum_{l=0}^{k-i}n_{l+i}2^{l}
	\end{equation*}
De esta manera, para obtener $a^n$ basta con calcular la sucesión desde el término $k$ hasta el término $0$. Como $k=\lfloor\log n\rfloor$, tenemos un algoritmo de exponenciación lineal respecto del número de cifras del exponente.
	\begin{figure}[H]
		\begin{minted}
			[frame=lines,
			framesep=2mm,
			baselinestretch=1,
			fontsize=\scriptsize,
			tabsize=4]
			{java}
public E power(E a, BigInteger k) {
	E result = getProductIdentity();
	if (!k.equals(BigInteger.ZERO)) {
		/* Repeated squaring algorithm. */
		String binaryExponent = k.toString(2);
		result = a;
		for (BigInteger i = new BigInteger(Integer.toString(binaryExponent.length() - 2)); i
		.compareTo(BigInteger.ZERO) >= 0; i = i.subtract(BigInteger.ONE)) {
			if (binaryExponent.charAt(binaryExponent.length() - 1 - i.intValue()) == '1') {
				result = multiply(multiply(result, result), a);
			} else {
				result = multiply(result, result);
			}
		}
	}
	return result;
}
		\end{minted}
		\caption{Código Java del algoritmo de exponenciación binaria.}
		\label{rep_sqr}
	\end{figure}
Este algoritmo está programado en la clase \mintinline{java}{Ring<E>}.
\subsection{Algoritmo de composición modular rápida}
\section{Algoritmo de Euclides simple}
	Sea $A$ un dominio euclídeo con función de grado $\varphi$. Recordemos, antes de comenzar, el siguiente resultado.
	\begin{lem}[Euclides]
		\label{lem_euclides}
		Dado $A$ un dominio, consideremos $a,b,q,r\in A$ que verifican $a=bq+r$. Entonces, si existen, tanto el máximo común divisor de $a$ y $b$, como el de $b$ y $r$, coinciden \textbf{salvo unidades}.
	\end{lem}
	
	Consideramos dos elementos $a,b\in A$, siendo $b\not=0$. Nuestro objetivo es \tb{calcular el máximo común divisor} de $a$ y $b$.
	
	Para ello, dividimos $a$ entre $b$, obteniendo dos elementos $q_1,r_1\in A$ tales que $a=bq_1+r_1$, siendo, o bien $r_1=0$, o bien $r_1\not=0$ y $\varphi(r_1)<\varphi(b)$. Esto es debido a que $A$ es un dominio euclídeo.
	
	Es claro que, si $r_1=0$, $b$ es divisor de $a$, y por tanto $b=\text{mcd}(a,b)$, con lo que habríamos terminado. En caso contrario, como por el lema \eqref{lem_euclides} se cumple que $\text{mcd}(a,b)=\text{mcd}(b,r_1)$, podemos repetir el proceso con $b$ y $r_1$, obteniendo dos nuevos elementos $q_2,r_2\in A$, cumpliendo hipótesis análogas a las que cumplían $q_1$ y $r_1$.
	
	Nótese que este proceso \tb{solo puede ser repetido un número finito de veces}, ya que, cada vez que repetimos el proceso, la función de grado del resto de la división decrece estrictamente.
	
	A este método de cálculo del máximo común divisor se le conoce como \tbi{algoritmo de Euclides}, y es precisamente el algoritmo que implementa el método \mintinline{java}{gcd(E a, E b)} de la clase \mintinline{java}{EuclideanDomain<E>}.
	\begin{figure}[H]
		\begin{minted}
			[frame=lines,
			framesep=2mm,
			baselinestretch=1,
			fontsize=\scriptsize,
			tabsize=4]
			{java}
public E gcd(E a, E b) {
	/* Euclid's algorithm. */
	while (!b.equals(getAddIdentity())) {
		E r = remainder(a, b);
		a = b;
		b = r;
	}
	return a;
}
		\end{minted}
		\caption{Código Java del algoritmo de Euclides.}
		\label{euclides}
	\end{figure}
\section{Algoritmo de Euclides extendido}
	Basándonos en el algoritmo de Euclides, podemos, además de calcular el máximo común divisor de dos números, extraer una \textbf{identidad de Bézout} que los relacione. Partimos de un dominio euclídeo $A$, considerando dos elementos $a,b\in A$, siendo $b$ no nulo.
	
	Procedemos, como en el algoritmo de Euclides, dividiendo $a$ y $b$, obteniendo $q_1,r_1\in A$ cumpliendo las hipótesis habituales que garantizan que nuestro procedimiento es finito.
	
	Despejando $r_1$ obtenemos que $r_1=a-q_1b$. Es decir, tenemos una \ti{\tb{``pseudo--identidad de Bézout''}}. Definimos $\alpha_1:=1$, $\beta_1:=-q_1$ para verlo más claro, \begin{equation*}
		r_1 = \alpha_1a +\beta_1b.
	\end{equation*}
	
	Usando el lema \eqref{lem_euclides}, como en el algoritmo anterior, tenemos que $\text{mcd}(a,b)=\text{mcd}(b,r_1)$, por lo que procedemos a dividir $b$ entre $r_1$, siempre y cuando $r_1\not=0$, al final veremos que el procedimiento es válido para todos los casos.
	
	De la división de  $b$ y $r_1$ obtenemos la igualdad $r_2=b-r_1q_2$, sustituyendo $r_1$ por la pseudo--identidad de Bézout, obtenemos, tras reordenar, una nueva pseudo--identidad de bezout, esta vez para $r_2$, esta es
	\begin{equation*}
		r_2=\alpha_2a+\beta_2b,
	\end{equation*}
	siendo $\alpha_2=-\alpha_1q_2$ y $\beta_2=1-\beta_1q_2$.
	
	Si repetimos el proceso una vez más, obtendremos una pseudo--identidad para $r_3$, siendo esta
	\begin{equation*}
		r_3=\alpha_3a+\beta_3b,
	\end{equation*}
	con $\alpha_3=\alpha_1-\alpha_2q_3$ y $\beta_3=\beta_1-\beta_2q_3$.
	
	Por inducción, no es complicado comprobar que la pseudo--identidad para $r_n$ tendrá por coeficientes
	\begin{equation*}
		\begin{array}{c}
			\alpha_n=\alpha_{n-2}-\alpha_{n-1}q_n\\
			\beta_n=\beta_{n-2}-\beta_{n-1}q_n
		\end{array}
	\end{equation*}
	Además, si definimos $\alpha_{-1}:=1$, $\alpha_{0}=0$, $\beta_{-1}=0$ y $\beta_{0}=1$, esta fórmula es válida para todo $n\in\N$.
	
	De esta manera, cuando llegamos a una iteración del procedimiento en la cual $r_l=0$, es decir, $r_{l-1}$ es el máximo común divisor, para obtener la identidad de Bézout basta recuperar los coeficientes $\alpha_{l-1}$ y $\beta_{l-1}$.
	
	Esto puede ir haciéndose sobre la marcha, con una implementación muy similar a la del cálculo de términos de la sucesión de Fibonacci. A este algoritmo se le conoce como \tbi{algoritmo de Euclides extendido}, y es el algoritmo programado en el método \mintinline{java}{bezout(E a, E b)} de la clase \mintinline{java}{EuclideanDomain<E>}.
	
	En el caso particular en el que $A[\texttt{x}]$ es un anillo de polinomios que es dominio euclídeo, se tiene el siguiente resultado, que usaremos más adelante.
	\begin{cor}[Grados de los coeficientes]
		Dados $f,g\in A[\texttt{x}]$ tales que el algoritmo de Euclides extendido devuelve la identidad de Bézout $uf+vg=h$, entonces se cumple que  $\deg(u)<\deg(g)-\deg(h)$ y $\deg(v)<\deg(f)-\deg(h)$.
	\end{cor}
	\begin{proof}
		Llamemos $\{u_i\}_{i=2}^{n}$ y $\{v_i\}_{i=2}^{n}$ a los coeficientes de las pseudo--identidades que va generando el algoritmo en cada iteración.
		
		Por inducción se demuestra muy fácilmente que $\deg(v_i)=\deg(f)-\deg(r_{i-1})$ y que $\deg(u_i)=\deg(g)-\deg(r_{i-1})$.
		
		Finalmente, como $\deg(r_n)<\deg(r_{n-1})$, se tienen ambas desigualdades.
	\end{proof}
	\begin{figure}[H]
		\begin{minted}
			[frame=lines,
			framesep=2mm,
			baselinestretch=1,
			fontsize=\scriptsize,
			tabsize=4]
			{java}
public Pair<E> bezout(E a, E b) {
	/* Extended Euclid's algorithm. */
	E alphaMinus1 = getAddIdentity();
	E alphaMinus2 = getProductIdentity();
	E betaMinus1 = getProductIdentity();
	E betaMinus2 = getAddIdentity();
	while (!b.equals(getAddIdentity())) {
		/* Computes division of a and b */
		E q = quotient(a, b);
		E r = remainder(a, b);
		
		/*
		* Just follow the formula for the new pseudo-bezout identity coefficients
		*/
		E alphaAux = add(alphaMinus2, getAddInverse(multiply(q, alphaMinus1)));
		E betaAux = add(betaMinus2, getAddInverse(multiply(q, betaMinus1)));
		
		/* Maintaining alphaMinusX and betaMinusX coherent */
		alphaMinus2 = alphaMinus1;
		betaMinus2 = betaMinus1;
		
		alphaMinus1 = alphaAux;
		betaMinus1 = betaAux;
		
		/* By euclid's lemma gcd(a,b) = gcd(b,r) */
		a = b;
		b = r;
	}
	return new Pair<E>(alphaMinus2, betaMinus2);
}
		\end{minted}
		\caption{Código Java del algoritmo de Euclides extendido.}
		\label{euclides_extendido}
	\end{figure}
\section{Algoritmo de Euclides primitivo}
	\section{Algoritmo del teorema chino de los restos}
	Recordamos brevemente el teorema chino de los restos.
	\begin{theo}[Teorema chino de los restos]
		Dado un anillo conmutativo y con unidad $A$, y $r$ ideales $I_1,\dots,I_r\subset A$ comaximales dos a dos, se cumple que la aplicación
		\begin{equation*}
			\begin{array}{cc}
			\phi:&A\to A/I_1\times\dots\times A/I_r\\
			& a\mapsto (a+I_1,\dots,a+I_r)
			\end{array}
		\end{equation*}
		es sobreyectiva.
	\end{theo}
	Lo que tratamos de hacer nosotros, por medio de un algoritmo, es hallar $\phi^{-1}$ de un elemento $(a_1+I_1,\dots,a_r+I_r)\in A/I_1\times\dots\times A/I_r$.
	\section{Algoritmo de inversión de elementos en $\mathbb{F}_q$}
	El algoritmo de inversión se basa en el siguiente resultado.
	\begin{prop}
		\label{prop_inversoFinito}
		Dado $A$ un dominio euclídeo con unidad y $a,m\in A$. $A$ es invertible en $A/mA$ si y solo si $\mathrm{mcd}(a,m)=1$.
	\end{prop}
	\begin{proof}
		En efecto, $a$ es una unidad si y solo si existe un $c\in A$ tal que $ac=1+\lambda m$. Despejando la igualdad obtenemos que $ac-\lambda m=1$, que es una identidad de Bézout con el elemento neutro del producto.
	\end{proof}
	Basta por tanto con darse cuenta de que el inverso de $a$ en la proposición \eqref{prop_inversoFinito} es el coeficiente de la identidad de Bézout que acompaña a $a$. Como podemos calcular los coeficientes de dicha identidad mediante el algoritmo de Euclides extendido, el algoritmo para obtener el inverso es inmediato.
	
	Únicamente hay que ser cuidadoso, sobre todo en $\mathbb{F}_q$, pues la identidad de Bézout obtenida puede estar expresada, no respecto del elemento neutro del producto, sino respecto de cualquier otra unidad.
	
	Se puede consultar el código de este algoritmo en los métodos \mintinline{java}{getProductInverse(T a)} de la clases \mintinline{java}{PrimeModuleIntegers} (que representan a los cuerpos $\Z_p$) y \mintinline{java}{PrimeQuotients}, que representan a los cuerpos $\mathbb{F}_q$.
		\begin{figure}[H]
		\begin{minted}
			[frame=lines,
			framesep=2mm,
			baselinestretch=1,
			fontsize=\scriptsize,
			tabsize=4]
			{java}
public FiniteFieldElement getProductInverse(FiniteFieldElement a) {
	/*
	* The greater common divisor will always be a unit, we just normalize it to be
	* the product identity, so the product inverse matches with the first
	* coefficient of the Bezout's identity.
	*/
	BigInteger factor = baseField.getProductInverse
	(polyRing.gcd(a.getPolynomial(), irrPolMod).leading());
	return new FiniteFieldElement(polyRing.remainder(
	polyRing.intMultiply((polyRing.bezout(a.getPolynomial(), irrPolMod).getFirst()), 
	factor), irrPolMod), irrPolMod);
}
		\end{minted}
		\caption{Código Java del algoritmo de Euclides de inversión de elementos en cuerpos finitos de orden potencia de primo.}
		\label{inversion}
	\end{figure}
	\section{Criterio de irreducibilidad en $\mathbb{F}_q[\texttt{x}]$}
	\section{Algoritmo de Cantor y Zassenhaus en $\mathbb{F}_q[\texttt{x}]$}
	\subsection{Fase I}
	\subsection{Fase II}
	\subsection{Fase III}
	\section{Algoritmo de Berlekamp en $\mathbb{F}_q[\texttt{x}]$}
	\section{Algoritmo de Kronecker en $\mathbb{Z}[\texttt{x}]$}
	\section{Algoritmo de factorización modular en $\mathbb{Z}[\texttt{x}]$}
	\section{Criterio de primalidad AKS en $\Z$}
	\section{Logaritmo discreto}
\end{document}