\documentclass[a4paper, 11pt, twoside, notitlepage, openany, onecolumn, final]{report}

\usepackage{style}

\title{\tb{Álgebra Computacional}}
\author{
	Álvaro García Tenorio
	\and
	Miguel Pascual Domínguez
}
\date{\today}

\begin{document}
	\maketitle
	\begin{abstract}
		En este documento se recopilan unas breves explicaciones sobre el funcionamiento de los algoritmos implementados.
	\end{abstract}
	\tableofcontents
	\chapter{Algoritmos implementados}
	\section{Algoritmos de Euclides}
	A continuación presentamos las diferentes variantes implementadas del algoritmo de Euclides.
	\subsection{Algoritmo de Euclides simple}
	Sea $A$ un dominio euclídeo con función de grado $\varphi$. Recordemos, antes de comenzar, el siguiente resultado.
	\begin{lem}[Euclides]
		\label{lem_euclides}
		Dado $A$ un dominio, consideremos $a,b,q,r\in A$ que verifican $a=bq+r$. Entonces, si existen, tanto el máximo común divisor de $a$ y $b$, como el de $b$ y $r$, esto coinciden \textbf{(salvo unidades)}.
	\end{lem}
	
	Consideramos dos elementos $a,b\in A$, siendo $b\not=0$. Nuestro objetivo es \tb{calcular el máximo común divisor} de $a$ y $b$.
	
	Para ello, dividimos $a$ entre $b$, obteniendo dos elementos $q_1,r_1\in A$ tales que $a=bq_1+r_1$, siendo, o bien $r_1=0$, o bien $r_1\not=0$ y $\varphi(r_1)<\varphi(b)$. Esto es debido a que $A$ es un dominio euclídeo.
	
	Es claro que si $r_1=0$, $b$ es divisor de $a$, y por tanto $b=\text{mcd}(a,b)$, con lo que habríamos terminado. En caso contrario, como por el lema \eqref{lem_euclides} se cumple que $\text{mcd}(a,b)=\text{mcd}(b,r_1)$, podemos repetir el proceso con $b$ y $r_1$, obteniendo dos nuevos elementos $q_2,r_2\in A$, cumpliendo hipótesis análogas a $q_1$ y $r_1$.
	
	Nótese que este proceso \tb{solo puede ser repetido un número finito de veces}, ya que, cada vez que repetimos el proceso, la función de grado del resto de la división decrece estrictamente.
	
	A este método de cálculo del máximo común divisor se le conoce como \tbi{algoritmo de Euclides}, y es precisamente el algoritmo que implementa el método \mintinline{java}{gcd(T a, T b)} de la clase \mintinline{java}{EuclideanDomain<T>}.
	\subsection{Algoritmo de Euclides extendido}
	Basándonos en el algoritmo de Euclides, podemos, además de calcular el máximo común divisor de dos números, extraer una \textbf{identidad de Bézout} que los relacione. Si bien esta extensión del algoritmo de Euclides sólo es válida para dominios euclídeos con unidad, como veremos a continuación.
	
	Partimos de un dominio euclídeo con unidad $A$, considerando dos elementos $a,b\in A$, siendo $b$ no nulo.
	
	Procedemos, como en el algoritmo de Euclides, dividiendo $a$ y $b$, obteniendo $q_1,r_1\in A$ cumpliendo las hipótesis habituales que garantizan que nuestro procedimiento es finito.
	
	Despejando $r_1$ obtenemos que $r_1=a-q_1b$. Es decir, tenemos una \ti{\tb{``pseudo--identidad de Bézout''}}. Definimos $\alpha_1:=1$, $\beta_1:=-q_1$ para verlo más claro, \begin{equation*}
		r_1 = \alpha_1a +\beta_1b.
	\end{equation*}
	
	Usando el lema \eqref{lem_euclides}, como en el algoritmo anterior, tenemos que $\text{mcd}(a,b)=\text{mcd}(b,r_1)$, por lo que procedemos a dividir $b$ entre $r_1$, siempre y cuando $r_1\not=0$, al final veremos que el procedimiento es válido para todos los casos.
	
	De la división de  $b$ y $r_1$ obtenemos la igualdad $r_2=b-r_1q_2$, sustituyendo $r_1$ por la pseudo--identidad de Bézout, obtenemos, tras reordenar, una nueva pseudo--identidad de bezout, esta vez para $r_2$, esta es
	\begin{equation*}
		r_2=\alpha_2a+\beta_2b,
	\end{equation*}
	siendo $\alpha_2=-\alpha_1q_2$ y $\beta_2=1-\beta_1q_2$.
	
	Si repetimos el proceso una vez más, obtendremos una pseudo--identidad para $r_3$, siendo esta
	\begin{equation*}
		r_3=\alpha_3a+\beta_3b,
	\end{equation*}
	con $\alpha_3=\alpha_1-\alpha_2q_3$ y $\beta_3=\beta_1-\beta_2q_3$.
	
	Por inducción, no es complicado comprobar que la pseudo--identidad para $r_n$ tendrá por coeficientes
	\begin{equation*}
		\begin{array}{c}
			\alpha_n=\alpha_{n-2}-\alpha_{n-1}q_n\\
			\beta_n=\beta_{n-2}-\beta_{n-1}q_n
		\end{array}
	\end{equation*}
	Además, si definimos $\alpha_{-1}:=1$, $\alpha_{0}=0$, $\beta_{-1}=0$ y $\beta_{0}=1$, esta fórmula es válida para todo $n\in\N$.
	
	De esta manera, cuando llegamos a una iteración del procedimiento en la cual $r_l=0$, es decir, $r_{l-1}$ es el máximo común divisor, para obtener la identidad de Bézout basta recuperar los coeficientes $\alpha_{l-1}$ y $\beta_{l-1}$.
	
	Esto puede ir haciéndose sobre la marcha, con una implementación muy similar a la del cálculo de términos de la sucesión de Fibonacci. A este algoritmo se le conoce como \tbi{algoritmo de Euclides extendido}, y es el algoritmo programado en el método \mintinline{java}{bezout} de la clase \mintinline{java}{EuclideanUnitDomain}.
	\subsection{Algoritmo de Euclides para polinomios sobre DFU's}
	\section{Algoritmo del teorema chino de los restos}
	Recordamos brevemente el teorema chino de los restos.
	\begin{theo}[Teorema chino de los restos]
		Dado un anillo conmutativo y con unidad $A$, y $r$ ideales $I_1,\dots,I_r\subset A$ comaximales dos a dos, se cumple que la aplicación
		\begin{equation*}
			\begin{array}{cc}
			\phi:&A\to A/I_1\times\dots\times A/I_r\\
			& a\mapsto (a+I_1,\dots,a+I_r)
			\end{array}
		\end{equation*}
		es sobreyectiva.
	\end{theo}
	Lo que tratamos de hacer nosotros, por medio de un algoritmo, es hallar $\phi^{-1}$ de un elemento $(a_1+I_1,\dots,a_r+I_r)\in A/I_1\times\dots\times A/I_r$.
	\section{Algoritmo de inversión de elementos en $\Z_p$ y $\mathbb{F}_q$}
	El algoritmo de inversión se basa en el siguiente resultado.
	\begin{prop}
		\label{prop_inversoFinito}
		Dado $A$ un dominio euclídeo con unidad y $a,m\in A$. $A$ es invertible en $A/mA$ si y solo si $\mathrm{mcd}(a,m)=1$.
	\end{prop}
	\begin{proof}
		En efecto, $a$ es una unidad si y solo si existe un $c\in A$ tal que $ac=1+\lambda m$. Despejando la igualdad obtenemos que $ac-\lambda m=1$, que es una identidad de Bézout con el elemento neutro del producto.
	\end{proof}
	Basta por tanto con darse cuenta de que el inverso de $a$ en la proposición \eqref{prop_inversoFinito} es el coeficiente de la identidad de Bézout que acompaña a $a$. Como podemos calcular los coeficientes de dicha identidad mediante el algoritmo de Euclides extendido, el algoritmo para obtener el inverso es inmediato.
	
	Únicamente hay que ser cuidadoso, sobre todo en $\mathbb{F}_q$, pues la identidad de Bézout obtenida puede estar expresada, no respecto del elemento neutro del producto, sino respecto de cualquier otra unidad.
	
	Se puede consultar el código de este algoritmo en los métodos \mintinline{java}{getProductInverse(T a)} de la clases \mintinline{java}{PrimeModuleIntegers} (que representan a los cuerpos $\Z_p$) y \mintinline{java}{PrimeQuotients}, que representan a los cuerpos $\mathbb{F}_q$.
\end{document}